(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
// WARNING: this file contains profanity. The below list of profane words is necessary for this tool to function properly.
// Do not read below this line if you do not wish to be exposed to lots of profane words
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = [
    "4r5e",
    "5h1t",
    "5hit",
    "a55",
    "anal",
    "anus",
    "ar5e",
    "arrse",
    "arse",
    "arses",
    "ass",
    "ass-fucker",
    "asses",
    "assfucker",
    "assfukka",
    "asshole",
    "assholes",
    "asswhole",
    "a_s_s",
    "a$$",
    "as$",
    "a$s",
    "b!tch",
    "b00bs",
    "b17ch",
    "b1tch",
    "ballbag",
    "balls",
    "ballsack",
    "bastard",
    "beastial",
    "beastiality",
    "bellend",
    "bestial",
    "bestiality",
    "bi+ch",
    "biatch",
    "bitch",
    "bitchboy",
    "bitcher",
    "bitchers",
    "bitches",
    "bitchin",
    "bitching",
    "bloody",
    "blow job",
    "blowjob",
    "blowjobs",
    "boiolas",
    "bollock",
    "bollok",
    "boner",
    "boob",
    "boobs",
    "booobs",
    "boooobs",
    "booooobs",
    "booooooobs",
    "breasts",
    "buceta",
    "bugger",
    "bullshit",
    "bum",
    "butt",
    "butts",
    "butthole",
    "buttmuch",
    "buttplug",
    "c0ck",
    "c0cksucker",
    "carpet muncher",
    "cawk",
    "chink",
    "cipa",
    "cl1t",
    "clit",
    "clitoris",
    "clits",
    "cnut",
    "cock",
    "cock-sucker",
    "cockface",
    "cockhead",
    "cockmunch",
    "cockmuncher",
    "cocks",
    "cocksuck",
    "cocksucked",
    "cocksucker",
    "cocksucking",
    "cocksucks",
    "cocksuka",
    "cocksukka",
    "cok",
    "cokmuncher",
    "coksucka",
    "coon",
    "cox",
    "crap",
    "cum",
    "cummer",
    "cumming",
    "cums",
    "cumshot",
    "cunilingus",
    "cunillingus",
    "cunnilingus",
    "cunt",
    "cuntlick",
    "cuntlicker",
    "cuntlicking",
    "cunts",
    "cyalis",
    "cyberfuc",
    "cyberfuck",
    "cyberfucked",
    "cyberfucker",
    "cyberfuckers",
    "cyberfucking",
    "d1ck",
    "damn",
    "dick",
    "dickhead",
    "dildo",
    "dildos",
    "dink",
    "dinks",
    "dirsa",
    "dlck",
    "dog-fucker",
    "doggin",
    "dogging",
    "donkeyribber",
    "doosh",
    "duche",
    "dyke",
    "ejaculate",
    "ejaculated",
    "ejaculates",
    "ejaculating",
    "ejaculatings",
    "ejaculation",
    "ejakulate",
    "f u c k",
    "f u c k e r",
    "f4nny",
    "fag",
    "fagging",
    "faggitt",
    "faggot",
    "faggs",
    "fagot",
    "fagots",
    "fags",
    "fanny",
    "fannyflaps",
    "fannyfucker",
    "fanyy",
    "fatass",
    "fcuk",
    "fcuker",
    "fcuking",
    "feck",
    "fecker",
    "felching",
    "fellate",
    "fellatio",
    "fingerfuck",
    "fingerfucked",
    "fingerfucker",
    "fingerfuckers",
    "fingerfucking",
    "fingerfucks",
    "fistfuck",
    "fistfucked",
    "fistfucker",
    "fistfuckers",
    "fistfucking",
    "fistfuckings",
    "fistfucks",
    "flange",
    "fook",
    "fooker",
    "fuck",
    "fucka",
    "fucked",
    "fucker",
    "fuckers",
    "fuckhead",
    "fuckheads",
    "fuckin",
    "fucking",
    "fuckings",
    "fuckingshitmotherfucker",
    "fuckme",
    "fucks",
    "fuckwhit",
    "fuckwit",
    "fudge packer",
    "fudgepacker",
    "fuk",
    "fuker",
    "fukker",
    "fukkin",
    "fuks",
    "fukwhit",
    "fukwit",
    "fux",
    "fux0r",
    "f_u_c_k",
    "gangbang",
    "gangbanged",
    "gangbangs",
    "gaylord",
    "gaysex",
    "goatse",
    "god-dam",
    "god-damned",
    "goddamn",
    "goddamned",
    "hardcoresex",
    "headass",
    "hoar",
    "hoare",
    "hoer",
    "hoes",
    "homo",
    "hore",
    "horniest",
    "horny",
    "hotsex",
    "jack-off",
    "jackoff",
    "jap",
    "jerk-off",
    "jism",
    "jiz",
    "jizm",
    "jizz",
    "kawk",
    "knobead",
    "knobed",
    "knobend",
    "knobhead",
    "knobjocky",
    "knobjokey",
    "kock",
    "kondum",
    "kondums",
    "kum",
    "kummer",
    "kumming",
    "kums",
    "kunilingus",
    "l3i+ch",
    "l3itch",
    "labia",
    "lust",
    "lusting",
    "m0f0",
    "m0fo",
    "m45terbate",
    "ma5terb8",
    "ma5terbate",
    "masochist",
    "master-bate",
    "masterb8",
    "masterbat*",
    "masterbat3",
    "masterbate",
    "masterbation",
    "masterbations",
    "masturbate",
    "mo-fo",
    "mof0",
    "mofo",
    "mothafuck",
    "mothafucka",
    "mothafuckas",
    "mothafuckaz",
    "mothafucked",
    "mothafucker",
    "mothafuckers",
    "mothafuckin",
    "mothafucking",
    "mothafuckings",
    "mothafucks",
    "motherfuck",
    "motherfucked",
    "motherfucker",
    "motherfuckers",
    "motherfuckin",
    "motherfucking",
    "motherfuckings",
    "motherfuckka",
    "motherfucks",
    "muff",
    "muthafecker",
    "muthafuckker",
    "mutherfucker",
    "n1gga",
    "n1gger",
    "nazi",
    "nigg3r",
    "nigg4h",
    "nigga",
    "niggah",
    "niggas",
    "niggaz",
    "nigger",
    "niggers",
    "nob",
    "nob jokey",
    "nobhead",
    "nobjocky",
    "nobjokey",
    "numbnuts",
    "nutsack",
    "orgasim",
    "orgasims",
    "orgasm",
    "orgasms",
    "p0rn",
    "pawn",
    "pecker",
    "penis",
    "penisfucker",
    "phonesex",
    "phuck",
    "phuk",
    "phuked",
    "phuking",
    "phukked",
    "phukking",
    "phuks",
    "phuq",
    "pigfucker",
    "pimpis",
    "piss",
    "pissed",
    "pisser",
    "pissers",
    "pisses",
    "pissflaps",
    "pissin",
    "pissing",
    "pissoff",
    "poop",
    "porn",
    "porno",
    "pornography",
    "pornos",
    "prick",
    "pricks",
    "pron",
    "pube",
    "pusse",
    "pussi",
    "pussies",
    "pussy",
    "pussys",
    "rectum",
    "retard",
    "rimjaw",
    "rimming",
    "s hit",
    "s.o.b.",
    "sadist",
    "schlong",
    "screwing",
    "scroat",
    "scrote",
    "scrotum",
    "semen",
    "sex",
    "sh!+",
    "sh!t",
    "sh1t",
    "shag",
    "shagger",
    "shaggin",
    "shagging",
    "shemale",
    "shi+",
    "shit",
    "shitdick",
    "shite",
    "shited",
    "shitey",
    "shitfuck",
    "shitfull",
    "shithead",
    "shiting",
    "shitings",
    "shits",
    "shitted",
    "shitter",
    "shitters",
    "shitting",
    "shittings",
    "shitty",
    "skank",
    "slut",
    "sluts",
    "smegma",
    "smut",
    "snatch",
    "son-of-a-bitch",
    "spac",
    "spunk",
    "s_h_i_t",
    "t1tt1e5",
    "t1tties",
    "teets",
    "teez",
    "testical",
    "testicle",
    "tit",
    "titfuck",
    "tits",
    "titt",
    "tittie5",
    "tittiefucker",
    "titties",
    "tittyfuck",
    "tittywank",
    "titwank",
    "tosser",
    "turd",
    "tw4t",
    "twat",
    "twathead",
    "twatty",
    "twunt",
    "twunter",
    "v14gra",
    "v1gra",
    "vagina",
    "viagra",
    "vulva",
    "w00se",
    "wang",
    "wank",
    "wanker",
    "wanky",
    "whoar",
    "whore",
    "willies",
    "willy",
];

},{}],2:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./profanity"), exports);
__exportStar(require("./profanity-options"), exports);

},{"./profanity":7,"./profanity-options":6}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CensorType = void 0;
var CensorType;
(function (CensorType) {
    CensorType[CensorType["Word"] = 0] = "Word";
    CensorType[CensorType["FirstChar"] = 1] = "FirstChar";
    CensorType[CensorType["FirstVowel"] = 2] = "FirstVowel";
    CensorType[CensorType["AllVowels"] = 3] = "AllVowels";
})(CensorType = exports.CensorType || (exports.CensorType = {}));

},{}],4:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./censor-type"), exports);
__exportStar(require("./list"), exports);

},{"./censor-type":3,"./list":5}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.List = void 0;
class List {
    constructor(onListChanged) {
        this.onListChanged = onListChanged;
        this.words = [];
    }
    get empty() {
        return !this.words.length;
    }
    removeWords(words) {
        this.words = this.words.filter((x) => !words.includes(x));
        this.onListChanged();
    }
    addWords(words) {
        this.words = this.words.concat(words);
        this.onListChanged();
    }
}
exports.List = List;

},{}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProfanityOptions = void 0;
class ProfanityOptions {
    constructor() {
        this.wholeWord = true;
        this.grawlix = "@#$%&!";
        this.grawlixChar = "*";
    }
}
exports.ProfanityOptions = ProfanityOptions;

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.profanity = exports.Profanity = void 0;
const profanity_options_1 = require("./profanity-options");
const models_1 = require("./models");
const misc_1 = require("./utils/misc");
const profane_words_1 = require("./data/profane-words");
class Profanity {
    constructor(options) {
        this.options = options || new profanity_options_1.ProfanityOptions();
        this.whitelist = new models_1.List(() => this.buildRegex());
        this.blacklist = new models_1.List(() => this.buildRegex());
        this.blacklist.addWords(profane_words_1.default);
    }
    exists(text) {
        this.regex.lastIndex = 0;
        return this.regex.test(text);
    }
    censor(text, censorType = models_1.CensorType.Word) {
        switch (censorType) {
            case models_1.CensorType.Word:
                return text.replace(this.regex, this.options.grawlix);
            case models_1.CensorType.FirstChar: {
                let output = text;
                Array.from(text.matchAll(this.regex)).forEach((match) => {
                    const word = match[0];
                    const grawlix = this.options.grawlixChar + word.slice(1, word.length);
                    output = output.replace(word, grawlix);
                });
                return output;
            }
            case models_1.CensorType.FirstVowel:
            case models_1.CensorType.AllVowels: {
                const regex = new RegExp("[aeiou]", censorType === models_1.CensorType.FirstVowel ? "i" : "ig");
                let output = text;
                Array.from(text.matchAll(this.regex)).forEach((match) => {
                    const word = match[0];
                    const grawlix = word.replace(regex, this.options.grawlixChar);
                    output = output.replace(word, grawlix);
                });
                return output;
            }
            default:
                throw new Error(`Invalid replacement type: "${censorType}"`);
        }
    }
    addWords(words) {
        this.blacklist.addWords(words);
    }
    removeWords(words) {
        this.blacklist.removeWords(words);
    }
    buildRegex() {
        const escapedBlacklistWords = this.blacklist.words.map(misc_1.escapeRegExp);
        const escapedWhitelistWords = this.whitelist.words.map(misc_1.escapeRegExp);
        const blacklistPattern = `${this.options.wholeWord ? "\\b" : ""}(${escapedBlacklistWords.join("|")})${this.options.wholeWord ? "\\b" : ""}`;
        const whitelistPattern = this.whitelist.empty ? "" : `(?!${escapedWhitelistWords.join("|")})`;
        this.regex = new RegExp(whitelistPattern + blacklistPattern, "ig");
    }
}
exports.Profanity = Profanity;
exports.profanity = new Profanity();
exports.default = exports.profanity;

},{"./data/profane-words":1,"./models":4,"./profanity-options":6,"./utils/misc":8}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeRegExp = void 0;
/**
 * Escapes all Regular Expression characters in a string
 * @param text the string to escape
 * @returns an escaped string
 */
const escapeRegExp = (text) => {
    return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
exports.escapeRegExp = escapeRegExp;

},{}],9:[function(require,module,exports){
let sendButtonAnon;
let sendButtonUser;
let chatDisplay;
let typeMessage;
let accountInformation;
let usernameField;
let passwordField;
let signInButton;
let signUpButton;
let logOutButton;
let chatbar;
let favoritesPopup;
let groupsPopup;
let myGroupsButton;
let createGroupButton;
let groupName;
let isPrivate;
let submitGroupButton;
let joinGroupButton;
let groupsSideDiv;
let groupsList;
let groupsListDiv;
let joinGroupList;
let joinGroupsListDiv;
let currentChatName;
let accountPage;

window.localStorage.clear();

let currentGroup = "0"; // 0 = General

//run 'browserify index.js -o bundle.js' for every change made to index.js. This ensures changes get moved over to bundle.js w/ browserify.
//https://browserify.org/
//implement @2toad profanity package
var profanity = require('@2toad/profanity').profanity;

getAllElements();
checkForSignedIn();

//Set the interval at which the updatesidebarButtonsMessages() function is run.
const MILLISECONDS_IN_ONE_SECOND = 1000;
setInterval(updateMessages, MILLISECONDS_IN_ONE_SECOND);

//for all needed, getElementById()
async function getAllElements(){
  sendButtonAnon = document.getElementById("sendButtonAnon");//Button to Send Anonymously
  sendButtonUser = document.getElementById("sendButtonAsUser");//Button to Send as yourself (username)
  chatDisplay = document.getElementById("chatDisplay");//Box the chat is diplayed in
  typeMessage = document.getElementById("typeMessage");//Box you type the message you would like to send in
  accountInformation = document.getElementById("accountInformation");//Div containing sign in/current user info
  usernameField = document.getElementById("usernameInput");//Username field to sign in
  passwordField = document.getElementById("passwordInput");//Password field to sign in
  signInButton = document.getElementById("signInButton");//Button to sign in
  signUpButton = document.getElementById("signUpButton");//Button to sign up, see TODO
  logOutButton = document.getElementById("logOutButton");//Button to log out current user
  chatbar = document.getElementById("chatbar");//Div containing both send message buttons and typeMessage
  favoritesPopup = document.getElementById("favoritesPopup");
  groupsPopup = document.getElementById("groupsPopup");
  myGroupsButton = document.getElementById("myGroupsButton");//Button to see the current user's groups
  createGroupButton = document.getElementById("createGroupButton");//Button to create a group
  groupName = document.getElementById("groupName");//Group name from the Create group form
  isPrivate = document.getElementById("isPrivate");//Returns if this created group will be private
  submitGroupButton = document.getElementById("submitGroupButton");//Button to submit the create group form
  joinGroupButton = document.getElementById("joinGroupButton");//Button to join a group
  groupsSideDiv = document.getElementById("groupsSideDiv");//Div for groups sidebar content
  groupsList = document.getElementById("groupsList");//List of user's groups
  groupsListDiv = document.getElementById("groupsListDiv");//Div containing groupsList
  joinGroupList = document.getElementById("joinGroupList");//List of joinable groups
  joinGroupsListDiv = document.getElementById("joinGroupsListDiv");//Div containing joinGroupList
  currentChatName = document.getElementById("currentChatName");
  accountPage = document.getElementById("accountPage");//Account Page Button
}

//Checks to see if the user is signed in. HTML is changed based on true/false.
async function checkForSignedIn(){
  //Get the current user data
  let currentUser = await Parse.User.currentAsync();

  //if a user is signed in
  if(currentUser != null){
    accountPage.innerHTML =
    `
    <li class="account"><a href="resources/html/account.html">Account</a></li>
    `;

    accountInformation.innerHTML = 
    `
    <p class="signInWelcome">Welcome, ${currentUser.get('username')}</p>
    <button id="logOutButton" class="logOutBTN" type="button">Log Out</button>
    `;

    chatbar.innerHTML = 
    `
      <input id ="typeMessage" class="typeMessageUser" type="text" placeholder="Type a message ...">
      <button id="sendButtonAnon" class="sendMessageAnonBTN" type="button">Send as: A Classmate</button>
      <button id="sendButtonAsUser" class="sendMessageUserBTN" type="button">Send as: ${currentUser.get('username')}</button>
    `;

    groupsPopup.innerHTML = 
    `
      <h1>Your Groups</h1>
      <button id="myGroupsButton" type="button">My Groups</button>
      <button id="createGroupButton" type="button">Create Group</button>
      <button id="joinGroupButton" type="button">Join Group</button>
      <a href="#" class="popup-box-close">X</a>
      <div id="groupsSideDiv">
        <p>Select a group to view the chat.</p>
        <p>
          <div id="groupsListDiv">
            <ul id="groupsList"> 
            </ul>
          </div>
        </p>
      </div>
    `;

    listGroups();
    getAllElements();

    //Adds logout button logic
    logOutButton.addEventListener("click", function(logOutButtonEvent){
      logOutButtonEvent.preventDefault();
      logOut();
    });

    //Adds send as a user logic
    //Send as a User (USERNAME)
    sendButtonUser.addEventListener("click", function(sendButtonUserClickEvent){
      sendButtonUserClickEvent.preventDefault();
      saveNewMessageUser(typeMessage.value);
      updateMessages();
      typeMessage.value = "";
    });

    //Adds send anon logic
    sendButtonAnon.addEventListener("click", function(sendButtonAnonClickEvent){
      sendButtonAnonClickEvent.preventDefault();
      saveNewMessageAnon(typeMessage.value);
      updateMessages();
      typeMessage.value = "";
    });

    //Adds My Groups logic
    myGroupsButton.addEventListener("click", function(myGroupsButtonClickEvent){
      myGroupsButtonClickEvent.preventDefault();

      groupsSideDiv.innerHTML = 
    `
      <p>Select a group to view the chat.</p>
      <p>
        <div id="groupsListDiv">
          <ul id="groupsList"> 
          </ul>
        </div>
      </p>
    `;

    listGroups();
    getAllElements();
    });

    //Adds create group logic
    createGroupButton.addEventListener("click", function(createGroupButtonClickEvent){
      createGroupButtonClickEvent.preventDefault();

      groupsSideDiv.innerHTML =
      `
        <p>Please complete all of the following fields to create a group.</p>
        
        <br>

        <div id="groupInfo">
          <label for="groupName">Group Name:</label>
          <input type="text" id="groupName" name="groupName" />
          
          <br><br>

          <label for="isPrivate">Private:</label>
          <input type="checkbox" id="isPrivate" name="isPrivate" />
        </div>

        <br><br>

        <button id="submitGroupButton" type="button">Submit</button>
      `;
      getAllElements;
      try{
        addSubmitGroupEvent;
      }
      catch{
        console.log(`Unable to add event listener to submit group button.`)
      }
    });

    joinGroupButton.addEventListener("click", function(joinGroupButtonClickEvent){
      joinGroupButtonClickEvent.preventDefault();

      groupsSideDiv.innerHTML = 
      `
        <p>Please select a group to join it.</p>
        <p>
          <div id="joinGroupsListDiv">
            <ul id="joinGroupList">
            </ul>
          </div>
        </p>
      `;

      listJoinableGroups();
      getAllElements();
    })


  }   
  //if a user is not signed in
  else{
    accountPage.innerHTML =
    `
    
    `;//clears accountPage section
    accountInformation.innerHTML = 
    `
      <input id="usernameInput" class="usernameInput" type="text" placeholder="Username"></input>
      <input id="passwordInput" class="passwordInput"type="password" placeholder="Password"></input>
      <button id="signInButton" class="signInButton" type="button">Sign In</button>
      <button id="signUpButton" class="signUpButton" type="button">Sign Up</button>
    `;

    chatbar.innerHTML = 
    `
      <input id ="typeMessage" class="typeMessageAnon" type="text" placeholder="Type a message ...">
      <button id="sendButtonAnon" class="sendMessageAnonBTN" type="button">Send as: A Classmate</button>
    `;

    favoritesPopup.innerHTML =
    `
      <h1>Your Favorites</h1>
      <p>Please sign in to view your favorites.</p>
      <a href="#" class="popup-box-close">X</a>
    `;

    groupsPopup.innerHTML = 
    `
      <h1>Your Groups</h1>
      <p>Please sign in to view your groups.</p>
      <a href="#" class="popup-box-close">X</a>
    `;

    getAllElements();

    //Adds signUpButtonLogic
    //TODO: Was setup temporarily to create mock users
    signUpButton.addEventListener("click", function(signUpButtonClickEvent){
    signUpButtonClickEvent.preventDefault();
    signUp();
    });

    //Adds signInButtonLogic
    signInButton.addEventListener("click", function(signInButtonClickEvent){
    signInButtonClickEvent.preventDefault();
    signIn();
    });

    //Adds send anon logic
    sendButtonAnon.addEventListener("click", function(sendButtonAnonClickEvent){
      sendButtonAnonClickEvent.preventDefault();
      saveNewMessageAnon(typeMessage.value);
      updateMessages();
      typeMessage.value = "";
    });
  }
}

//Updates the list of messages
async function updateMessages(){
  try{
    const messages = new Parse.Query("Message");
    messages.ascending("createdAt");
    const results = await messages.find();

    let messagesString = "";

    for (let i = 0; i < results.length; i++){
      const object = results[i];
      if(object.get("groupID") == currentGroup){
        const messageString = object.get("sender") + ": (" + object.get("createdAt")  + ") " + object.get("contents") + "\n";
        messagesString += messageString;
      }
    }

    chatDisplay.value = messagesString;
  } 
  catch(error){
    alert(`Failed to retrieve messages, with error code: ${error.message}`);
  }
}

//Log In to an account
async function signIn(){
  var username = usernameField.value;
  var password = passwordField.value;
  try{
    var user = Parse.User
    .logIn(username, password);
    await delay(1000);
    //setTimeout(checkForSignedIn(), 1000);
    checkForSignedIn();
  }
  catch(error){
    alert("Failed to sign in with error code: " + error.message);
  }
  
}

//TODO: Was setup temporarily to create mock users
async function signUp(){
  //Create a new instance of the user class
  try{
    var user = new Parse.User();
    user.set("username", "lambrics");
    user.set("password", "1234");
    user.set("email", "lambrics@ucmail.uc.edu");
    user.signUp();
    checkForSignedIn();
  }
  catch(error){
    alert('Failed to create user, with error code: ' + error.message);
  }
}

//Logs out the current user
async function logOut(){
  try{
    Parse.User.logOut();
    await delay(1000);
    checkForSignedIn();
  }
  catch(error){
    alert("Failed to log out with error code: " + error.message)
  }
}

//Send as A Classmate (ANONYMOUS)
//Sends a message anonymously as "A Classmate"
async function saveNewMessageAnon(Message){
  try{
    //check for profanity
    if(profanity.exists(Message)){
      alert('The message you are trying to send contains language others may consider offensive. Please refrain from using language others may find harmful or offensive.');
    }
    else{
      const message = new Parse.Object("Message");
      message.set("sender", "A Classmate");
      message.set("contents", Message);
      message.set("groupID", currentGroup);
      let result = await message.save();
    }
  }
  catch(error){
    alert('Failed to send message, with error code: ' + error.message);
  }
}

//Sends a message NON anonymously as username
async function saveNewMessageUser(Message){
  try{
    //check for profanity
    if(profanity.exists(Message)){
      alert('The message you are trying to send contains language others may consider offensive. Please refrain from using language others may find harmful or offensive.')
    }
    else{
      const message = new Parse.Object("Message");
      let currentUser = await Parse.User.currentAsync();
      let currentUsername = currentUser.get('username');
      message.set("sender", currentUsername);
      message.set("contents", Message);
      message.set("groupID", currentGroup);
      let result = await message.save(); 
    }
  }
  catch(error){
    alert('Failed to send message, with error code: ' + error.message);
  }
}

async function addSubmitGroupEvent(){
  submitGroupButton.addEventListener("click", function(submitGroupButtonClickEvent){
    submitGroupButtonClickEvent.preventDefault();
    getAllElements();
    createGroup();
    //go back to My Groups
    groupsSideDiv.innerHTML = 
    `
      <p>Select a group to view the chat.</p>
      <p>
        <div id="groupsListDiv">
          <ul id="groupsList"> 
          </ul>
        </div>
      </p>
    `;

    listGroups();
    getAllElements();
  });
}

async function createGroup(){
  //Verify a name was entered
  if(groupName.value == "" || groupName.value == " "){
    alert('Failed to create group, a group name was not entered.');
  }
  else{
    //Check for profanity
    if(profanity.exists(groupName.value)){
      alert('Failed to create group, profanity was used.');
    }
    else{
      //Verify that the desired name is not already being used.
      let doesExist = false;
      try{
        const groups = new Parse.Query("Group");
        const results = await groups.find();

        for(let i = 0; i < results.length; i++){
          const group = results[i];
          const existingName = group.get("name");
          if(existingName.toLowerCase() == groupName.value.toLowerCase() || groupName.value.toLowerCase() == "general"){
            doesExist = true;
          }
        }

        if(doesExist){
          alert(`The group name, ${groupName.value}, is already in use. Please try again with another name.`);
        }
        else{

          //Create the group
          const newGroup = new Parse.Object("Group");
          let currentUser = await Parse.User.currentAsync();
          let members = [currentUser.get("username")];
          group.set("name", groupName.value);
          group.set("members", members);
          group.set("isPrivate", isPrivate.checked);
          let result = await group.save();
          delay(MILLISECONDS_IN_ONE_SECOND);
        }
      }
      catch(error){
        alert('Failed to create group, with error code: ' + error.message);
      }
    }
  }   
}

//My Groups
async function listGroups(){
  getAllElements();
  try{
    groupsListDiv.innerHTML = 
    `
        <ul id="groupsList">
          
        </ul>
    `;
    
    getAllElements();
    const groups = new Parse.Query("Group");
    groups.ascending("name");
    const results = await groups.find();

    //List general
    let liGeneral = document.createElement("li");
    liGeneral.innerText = "General";
    liGeneral.addEventListener("click", function(selectGeneralClickEvent){
      selectGeneralClickEvent.preventDefault();
      selectGroup("0", "General");
    })
    groupsList.appendChild(liGeneral);

    //List other groups
    for (let i = 0; i < results.length; i++){
      const group = results[i];
      const groupMembers = group.get("members");
      const groupId = group.id;
      const groupName = group.get("name");
      const currentUser = await Parse.User.currentAsync();
      const currentUsername = currentUser.get('username');
      if(groupMembers.includes(currentUsername)){
        let li = document.createElement("li");
        li.innerText = groupName;

        //add selection logic to li items
        li.addEventListener("click", function(selectGroupClickEvent){
          selectGroupClickEvent.preventDefault();
          selectGroup(groupId, groupName);
        })
        groupsList.appendChild(li);
      }
    }
  }
  catch(error){
    alert(`Failed to get groups with error code: ${error.message}`);
  }
}

//Join Group
async function listJoinableGroups(){
  getAllElements();
  try{
    joinGroupsListDiv.innerHTML = 
    `
      <ul id="joinGroupList">

      </ul>
    `;
    getAllElements();

    //get all groups
    const groups = new Parse.Query("Group");
    groups.ascending("name");
    const results = await groups.find();

    //List joinable groups (groups that are not private and does not contain the current signed in user)
    for(let i = 0; i < results.length; i++){
      const group = results[i];
      const groupId = group.id;
      const groupMembers = group.get("members");
      const groupName = group.get("name");
      const currentUser = await Parse.User.currentAsync();
      const currentUsername = currentUser.get('username');
      if(!(groupMembers.includes(currentUsername))){
        let li = document.createElement("li");
        li.innerText = groupName;

        li.addEventListener("click", function(joinGroupClickEvent){
          joinGroupClickEvent.preventDefault();
          joinGroup(groupId, groupName, groupMembers, currentUsername);
        })
        joinGroupList.append(li);
      }
    }
  }
  catch(error){
    alert(`Failed to fetch joinable groups with error code: ${error.message}`);
  }
}

//Chat Selection
async function selectGroup(GroupId, GroupName){
  currentGroup = GroupId;
  currentGroupName = GroupName;
  currentChatName.innerHTML = `${currentGroupName}`;
}

//Join Group
async function joinGroup(GroupId, GroupName, GroupMembers, CurrentUsername){
  //get all groups
  const groups = new Parse.Query("Group");
  const groupToJoin = await groups.get(GroupId);
  let members = GroupMembers;
  members.push(CurrentUsername);
  groupToJoin.set("members", members);
  await groupToJoin.save();
  alert(`You have been added to group, ${GroupName}`);

  selectGroup(GroupId, GroupName);

  //go back to My Groups
  groupsSideDiv.innerHTML = 
    `
      <p>Select a group to view the chat.</p>
      <p>
        <div id="groupsListDiv">
          <ul id="groupsList"> 
          </ul>
        </div>
      </p>
    `;

    listGroups();
    getAllElements();
}

function delay(milliseconds){
  return new Promise(resolve => {
      setTimeout(resolve, milliseconds);
  });
}
},{"@2toad/profanity":2}]},{},[9]);
